tracker peer obfuscation extension
==================================

This extends the tracker protocol to support simple obfuscation of the
peers it returns, using the info hash as a shared secret between the
peer and the tracker. The obfuscation does not provide any security
against eavesdroppers that know the infohash of the torrent.  The goal
is to prevent internet service providers and other network
administrators from blocking or disrupting bittorrent traffic
connections that span between the receiver of a tracker response and
any peer IP-port appearing in that tracker response.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are
to be interpreted as described in IETF `RFC 2119`_. 

.. _`RFC 2119`: http://tools.ietf.org/html/rfc2119


announce parameter
------------------

When using this extension, instead of passing the ``info_hash`` parameter
to the tracker, an ``sha_ih`` is passed.

The value of ``sha_ih`` MUST be the info-hash of the torrent, with a second
SHA-1 applied to it.

For example if a torrent has infohash with hex representation
``aaf4c61ddcc5e8a2dabedef3b482cd9aea9434d`` then its ``sha_ih`` is
``sha1(infohash)='6b4f89a54e2d27ecd7e8da5b4ab8fd9d1d8b119'``.

The value MUST be url encoded, just like the ``info_hash``.  Thus the
``sha_ih`` above when url encoded becomes
``kO%89%A5N-%27%EC%D7%E8%DA%05%B4%AB%8F%D9%D1%D8%B1%19``.

This extension does not change the semantics of any parameter passed
in the peer's announce.

announce response
-----------------

If the tracker supports this extension, the response should be exactly the
same as if the ``info_hash`` was passed, except that any field that contains
peer information (such as ``peers``, ``peers6`` or any other field defined
by another extension) MUST be obfuscated as described in the next section.

There are additional parameters the tracker may OPTIONALLY return.
These are discussed in the optimizations_ section.

peer list obfuscation
---------------------

We distinguish between the *tracker peer list* and the *returned peer
list*.  The *tracker peer list* contains the ip-port pairs of all
peers that have reported to the tracker that they are downloading or
seeding a given file with a given infohash.  The tracker may store
this peer list however it wishes.  The *returned peer list* contains a
packed array of ip-port pairs conforming to the BitTorrent protocol
specification.  If the swarm is sufficiently large then the returned
ip-port pairs constitute a subset of the ip-port pairs in the
*tracker peer list*.

The returned peer list is encrypted using RC4-drop768 encryption
using the infohash as a shared secret and optionally an initialization
vector.  To communicate an initialization vector, the tracker includes
in the bencoded response the key ``iv`` with value set to a byte
string containing the initialization vector.  The initialization
vector can be of arbitrary length and is sent in plaintext.

If the tracker sends no initialization vector then the first 64-bits
of the infohash are used as the RC4 key.  If the tracker provides an
initialization vector then the RC4 key is generated by appending the
vector to the infohash and then hashing with sha1.  The first 64 bits
of the resulting hash are then used as the RC4 key.

For example, given infohash ``aaf4c61ddcc5e8a2dabedef3b482cd9aea9434d``
and initialization vector ``abcd`` both represented in hex, the RC4 key
is derived as follows:

::
 
   hash = sha1( 'aaf4c61ddcc5e8a2dabedef3b482cd9aea9434dabcd' )
   key = hash[0:64]

where [i:j] denotes the ith through jth bit including the ith but
excluding the jth.  The resulting key in hex is ``f36e9cae87cf33e0``.

A 64-bit key is used to avoid U.S. export restrictions. 

It is RECOMMENDED that the tracker use the initialization vector, and
that it change the ``iv`` on roughly the same period as the rerequest
interval.  The reasoning for this is contained in the rationale.

optimizations
-------------

The described optimizations are OPTIONAL for the tracker, but the
corresponding client-side MUST be implemented by those that support
this extension.  These extensions hobble the strength of the RC4
encryption in order to improve tracker performance.  In the rationale_
section we discuss why hobbling RC4 is reasonable and in many cases
has negligible foreseen effect on security.

For the purpose of these optimizations we assume that the tracker
stores the tracker peer list for each infohash as a packed array that
can be copied directly into the response.  We further assume that the
packed array is reused many times and that with each request the
tracker either returns the entire packed array or copies a single
contiguous substring from the tracker peer list into the response.

If the peerlist is represented and used as assumed then to improve
randomness in the set of peers handed out by the tracker, it is
RECOMMENDED that the tracker periodically reshuffle the peerlist with
period similar to the rerequest interval.  After each reshuffle the
tracker reperforms the operations described in this section.

In the process of encryption, RC4 generates a pseudorandom string that
is XOR'd with the plaintext to generate the ciphertext.  The receiver
recovers the plaintext by generating the same pseudorandom string and
XOR'ing it with the cihphertext.  To reduce computation the tracker
may cache the pseudorandom string generated by RC4 and reuse it as
peers arrive and depart.

In generating the pseudorandom string, the tracker and client MUST
discard the first 768 bytes.

The tracker MAY also cache the encrypted tracker peer list.  To
support this the tracker must pass two additional keys *i* and *n*
each with integer values.  Decryption starts by XORing from *6i* bytes
for ipv4 (or *18i* for ipv6) into the pseudorandom sequence.  Assuming
that the tracker encrypted the tracker peer list starting from the
first byte in the pseudorandom string then *i* also corresponds to the
*i*th ip-port pair in the tracker peer list and the starting point of
the copy into the returned request.  

So that the client and the tracker do not have to generate an
arbitrarily long pseudorandom string to support large swarms, we
assume the tracker bounds the length of the pseudorandom string and
reports the length in ip-port pairs as the value to key *n*.  We
RECOMMEND that *n* be equal to the length of the tracker peer list or
random but within constant factor of the longest peerlist returned by
the tracker, whichever is smaller.  Thus the tracker encrypts the
*jth* byte of the *ith* ip-port pair in an ipv4 tracker peer list by
XORing with the byte *(6i+j)* `mod` *n* bytes into the pseudorandom
string.

Since providing *i* and *n* significantly reduces the cost for an
attacker to recover the pseudorandom string, the tracker MUST XOR the
value of *i* with the 32 bits beginning with the 8th least signifacant
byte of the infohash and *n* with the least significant 32 bits of the
infohash.  We do not use the first 64 bits of the infohash since the
first 64 bits are used as the RC4 key when not specifying an
initialization vector.
 
We describe encryption in the following example for an ipv4 tracker peer 
list consisting of 3 ip-port pairs, and using an RC4 pseudorandom string 
of length *n=2*. *n* is small for purposes of illustration.  Also, for the 
purpose of illustration, the tracker returns only 2 peers at a time.

::
  Given the following peer list
  (208.72.193.86, 6881), (209.81.173.15,14321), (128.213.6.8, 6881)

  As a packed array represented in hex it becomes
               
  d048c1561ae1d151ad0f37f180d506081ae1 

  which we XOR with an RC4 pseudorandom string, e.g.,

  a496e5f9b83e835013d42226

  to generate 

  74de24afa2df5201bedb15d72443e3f1a2df

Because the RC4 pseudorandom string is shorter than the tracker
peer list, we wrap to the beginning of the pseudorandom string.

  In the first response, the tracker would return

  *peers=74de24afa2df5201bedb15d7*, *i=0*, *n=2*

  In the second response, the tracker would return

  *peers=5201bedb15d72443e3f1a2df*, *i=1*, *n=2*

The tracker response MUST remain a valid bencoded message.

HERE.  I MAY REMOVE THE FOLLOWING PARAGRAPH --DAVE

Another application of this optimization would be a de-optimization using 
a much longer pre-computed RC4 pseudorandom string.  A tracker could 
randomly discard the first *6i* or *18i* bytes of the pseudorandom string, 
and send *i* and *n* in the response.  Even if the peerlist is identical 
in every response, the obfuscated peerlist will randomly differ.  For 
torrents with a small number of peers, doing this along with an 
intermittent update of the initialization vector should prevent any 
listeners from positively identifying peer IPs, or the infohash.

backwards compatibility
-----------------------

Trackers that support obfuscation are identified in the .torrent file
by the inclusion of an ``obfuscate-announce-list`` which otherwise has the 
same semantics as the ``announce-list`` key.  Peers that do not support
obfuscation simply ignore the ``obfuscate-announce-list``.  

A client that is configured to use this extension should always send
the ``sha_ih`` to any tracker supporting obfuscation.  The client
SHOULD only contact trackers in the ``announce-list`` once the client
has attempted all trackers in the ``obfuscate-announce-list`` and all failed. 

If a tracker that supports obfuscation wishes to allow legacy peers to
connect to the tracker then the announce URL should appear in both the
``obfuscate-announce-list`` and the ``announce-list``.

If a tracker URL appears in both lists running on the same port, and
the tracker failed to respond when selected from the
``obfuscate-announce-list`` then the client MAY treat the tracker in
the ``announce-list`` as if it were temporarily unreachable and defer
trying it until it has tried other trackers in the ``announce-list``.

Peers MUST never send both the ``info_hash`` and ``sha_ih`` parameters
in the same request, since that would defeat the purpose of the shared
secret.

rationale
---------

This extension directly addresses a known attack on the BitTorrent
protocol performed by some deployed network hardware.  By obscuring
the ip-port pairs network hardware can no longer easily identify
ip-port pairs that are running BitTorrent by observing peer-to-tracker
communications.  This deployed hardware under some conditions disrupts
BitTorrent connections by injecting forged TCP reset packets.  Once a
BitTorrent connection has been identified, other attacks could be
performed such as severely rate limiting or blocking these
connections.

This hardware was presumably deployed to get around BitTorrent
protocol encryption which increases the difficulty of identifying
BitTorrent traffic by directly inspecting peer-to-peer connections.

By using the SHA-1 of the infohash, the tracker is able to identify
torrents without sending the plaintext infohash and without requiring
an additional prior exchange of a shared secret.  Where trackers now
maintain mappings from infohash to the corresponding torrent's
peerlist and other torrent-specific state, obfuscated trackers would need 
one additional mapping from ``sha_ih`` to the torrent's state.
Tracker may also store encrypted versions of each torrent's peer list,
to increase computation performance at the expense of increasing
memory footprint by a constant factor.

The obfuscation method meets the following criteria:

- The entire plaintext of the peer list is not easily obtained
  even if an eavesdropper identifies ip-port pairs from
  subsequent connections from a peer that has received a tracker response.

- Even when a subsequent connection from a peer that has received a 
  tracker response is observed by an eavesdropper, it is difficult to 
  map the ip-port pair to specific ciphertext to verify that the
  connection is using BitTorrent.

When the optimizations_ are used,
 
- Few computations are performed at request time. 

- Encryption may be performed at the time a peer is added.
  The encrypted peer ip and port may be handed out hundreds of times.

- Security is minimally impacted.

The objective is NOT to create a cryptographically secure protocol
that can survive unlimited observation of passing packets and
substantial computational resources on network timescales.  The object
is to raise the bar sufficiently to deter attacks based on observing
ip-port numbers in peer-to-tracker communications.

If a tracker observes a large number of tracker requests and responses
and subsequent connections, it is possible to attack the encryption.
RC4 is known to have a number of weaknesses especially in the way it
was used with WEP [and HERE].  However, with tracker peer obfuscation, the
number of bytes transferred between the tracker and a client is likely
significantly smaller than transfer between a wireless computer and a
basestation.  An attacker faces a much larger task in obtaining
sufficient probable plaintext to directly break the encryption.

Hobbling the RC4 encryption by using a bounded-length RC4 pseudorandom
string for small swarms is likely to have negilgible impact on
security over any other encyption method since the pseudorandom string
is probably equal to or longer than the plaintext and thus no part of
it is repeated in the XOR except as peers arrive or leave the swarm.
Thus on the timescales of rerequest intervals, nearly the same
ciphertext is handed to every peer requesting the same infohash.
Intercepting the same ciphertext multiple times provides no additional
information to the attacker.  The attacker could correlate ip-port
pairs in connections following tracker responses, but an attacker
could do this regardless of the encryption method employed.
Furthermore more direct methods of traffic analysis applied to
peer-to-peer communication is available to network operators.

For larger swarms, hobbling RC4 may more significantly impact breaking
the encryption since the same pseudorandom string is used repeatedly
across the peer list.  Some study is in order on this point taking
into account that the tracker can periodically change intiailization
vectors.

We know from experience that periodically reshuffling peer lists on
the order of the rerequest interval negligibly impacts tracker
performance even with swarms containing millions of peers.  Generating
a new pseudorandom string using RC4 on this same time interval is
likely to incur negligible performance penalty because 1) it is a
small constant factor more expensive than a shuffle on an input string
of equal length, 2) the generated pseudoranom string is only *n* bytes
long where *n* is larger than the largest response size and thus much
smaller than the tracker peer list, and 3) the cost of the XOR
operation is lighter weight than performing a random shuffle.


authors
-------

| `David Harrison`__
| `Arvid Norberg`__
| `Greg Hazel`__
| `Anthony Ciani`__

.. __: mailto:dave@bittorrent.com
.. __: mailto:arvid@bittorrent.com
.. __: mailto:greg@bittorrent.com
.. __: mailto:tony@ciani.phy.uic.edu 

